# Instruction encoding

NoirForge (and the Sunspot verifier program) uses a simple on-chain verification payload.

## Instruction data

The instruction payload is a raw concatenation:

- `instruction_data = proof_bytes || public_witness_bytes`

The verifier program does not require any accounts (empty `accounts` array).

## Public witness format

The public witness bytes are:

- Total length: `12 + NR_INPUTS * 32`
- First 12 bytes: header
- Followed by `NR_INPUTS` entries of 32 bytes each

Each entry is interpreted as a 32-byte **big-endian** field element.

## Proof format

The proof bytes are parsed as:

- `A` (G1): 64 bytes
- `B` (G2): 128 bytes
- `C` (G1): 64 bytes
- `num_commitments` (u32, big-endian): 4 bytes
- `commitments`: `num_commitments * 64` bytes
- `commitment_pok`: 64 bytes

For circuits with no commitments:

- `num_commitments = 0`
- `proof_len = 324`

## Constructing payload

Given `.proof` and `.pw` files generated by Sunspot:

1) Read both files as raw bytes
2) Concatenate `proof_bytes` followed by `pw_bytes`
3) Send as Solana instruction data to the deployed verifier program
